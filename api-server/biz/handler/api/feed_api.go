// Code generated by hertz generator.

package api

import (
	"context"
	api "github.com/bytecamp-galaxy/mini-tiktok/api-server/biz/model/api"
	"github.com/bytecamp-galaxy/mini-tiktok/feed-server/kitex_gen/feed"
	"github.com/bytecamp-galaxy/mini-tiktok/feed-server/kitex_gen/feed/feedservice"
	"github.com/bytecamp-galaxy/mini-tiktok/pkg/constants"
	"github.com/bytecamp-galaxy/mini-tiktok/pkg/mw"
	"github.com/bytecamp-galaxy/mini-tiktok/pkg/utils"
	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/cloudwego/kitex/client"
	"github.com/cloudwego/kitex/pkg/klog"
	kitexzap "github.com/kitex-contrib/obs-opentelemetry/logging/zap"
	"github.com/kitex-contrib/registry-eureka/resolver"
)

// GetFeed .
// @router /douyin/feed/ [GET]
func GetFeed(ctx context.Context, c *app.RequestContext) {
	var err error
	var req api.FeedRequest

	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	// get the latest time.
	// if the latest time hasn't been passed as param, it's 0 by default.
	latest_time := req.GetLatestTime()
	token := req.GetToken()
	// fetch user id from token
	//id, ok := c.Get(jwt.IdentityKey)
	//if !ok {
	//	c.JSON(consts.StatusInternalServerError, &api.FeedResponse{
	//		StatusCode: 1,
	//		StatusMsg:  utils.String("broken invariant"),
	//		VideoList:  nil,
	//		NextTime:  nil,
	//	})
	//	return
	//}

	// set up connection with feed server
	r := resolver.NewEurekaResolver([]string{constants.EurekaServerUrl})
	cli, err := feedservice.NewClient("tiktok.feed.service",
		client.WithMiddleware(mw.CommonMiddleware),
		client.WithInstanceMW(mw.ClientMiddleware),
		client.WithResolver(r))
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.FeedResponse{
			StatusCode: 1,
			StatusMsg:  utils.String(err.Error()),
			VideoList:  nil,
			NextTime:   nil,
		})
		return
	}
	klog.SetLogger(kitexzap.NewLogger())
	klog.SetLevel(klog.LevelDebug)

	// call rpc service
	reqRpc := &feed.FeedRequest{
		LatestTime: &latest_time,
		Token:      &token,
	}
	respRpc, err := cli.GetFeed(ctx, reqRpc)
	if err != nil {
		c.JSON(consts.StatusInternalServerError, &api.FeedResponse{
			StatusCode: 1,
			StatusMsg:  utils.String(err.Error()),
			VideoList:  nil,
			NextTime:   nil,
		})
		return
	}

	// handle status code
	if respRpc.StatusCode != 0 {
		c.JSON(consts.StatusInternalServerError, &api.FeedResponse{
			StatusCode: respRpc.StatusCode,
			StatusMsg:  utils.String(*respRpc.StatusMsg),
			VideoList:  nil,
			NextTime:   nil,
		})
		return
	}

	// convert model.Videos to feed.Videos
	respVideos := make([]*api.Video, len(respRpc.VideoList))
	for i, video := range respRpc.VideoList {
		author := video.Author
		u := &api.User{
			Id:            author.Id,
			Name:          author.Name,
			FollowCount:   &author.FollowCount,
			FollowerCount: &author.FollowerCount,
			IsFollow:      author.IsFollow,
		}
		respVideos[i] = &api.Video{
			Id:            video.Id,
			Author:        u,
			PlayUrl:       video.PlayUrl,
			CoverUrl:      video.CoverUrl,
			FavoriteCount: video.FavoriteCount,
			CommentCount:  video.CommentCount,
			IsFavorite:    video.IsFavorite,
			Title:         video.Title,
		}
	}

	// response to client
	resp := &api.FeedResponse{
		StatusCode: respRpc.StatusCode,
		StatusMsg:  utils.String(*respRpc.StatusMsg),
		VideoList:  respVideos,
		NextTime:   respRpc.NextTime,
	}

	c.JSON(consts.StatusOK, resp)
}
